<html>
<head>

<title>WebGL</title>
<meta charset="utf-8">
<link rel='stylesheet' type='text/css' href='css/site.css' />
<script src="js/lib/underscore.js"></script>
<script src="js/lib/domready.js"></script>
<script src="js/lib/glmatrix.js"></script>
<script src="js/lib/webgl-debug.js"></script>
<script src="js/lib/bean.js"></script>
<script src="js/lib/dat.gui.js"></script>
<script src="js/util.js"></script>
<script src="js/hash.js"></script>
<script src="js/debug.js"></script>
<script src="js/mrucache.js"></script>
<script src="js/protobuf.js"></script>
<script src="js/glutil.js"></script>
<script src="js/fillbuffer.js"></script>
<script src="js/vertexbuffer.js"></script>
<script src="js/tile.js"></script>
<script src="js/rastertile.js"></script>
<script src="js/transform.js"></script>
<script src="js/parse_style.js"></script>
<script src="js/style.js"></script>
<script src="js/font.js"></script>
<script src="js/binpack.js"></script>
<script src="js/coordinate.js"></script>
<script src="js/interaction.js"></script>
<script src="js/debug_text.js"></script>
<script src="js/actor.js"></script>
<script src="js/dispatcher.js"></script>
<script src="js/imagesprite.js"></script>
<script src="js/glyphatlas.js"></script>
<script src="js/glyphvertexbuffer.js"></script>
<script src="js/map.js"></script>
<script src="js/layer.js"></script>
<script src="js/painter.js"></script>
<script src="js/site.js"></script>

<!-- these are the previous shaders -->
<script id="debug-vertex" type="x-shader/x-vertex">
precision mediump float;

attribute vec2 a_pos;

uniform float u_pointsize;
uniform mat4 u_posmatrix;

void main() {
    gl_Position = u_posmatrix * vec4(a_pos, step(32767.0, a_pos.x), 1);
    gl_PointSize = u_pointsize;
}
</script>
<script id="debug-fragment" type="x-shader/x-fragment">
precision mediump float;

uniform vec4 u_color;

void main() {
    gl_FragColor = u_color;
}
</script>

<script id="raster-vertex" type="x-shader/x-vertex">
    precision mediump float;
    uniform mat4 u_posmatrix;
    uniform float u_brightness_low;
    uniform float u_brightness_high;
    uniform float u_spin;
    attribute vec2 a_pos;
    varying vec2 v_pos;

    void main(void) {
        gl_Position = u_posmatrix * vec4(a_pos, step(32767.0, a_pos.x), 1);
        v_pos = a_pos / 4096.0;
    }
</script>
<script id="raster-fragment" type="x-shader/x-fragment">
    precision mediump float;

    uniform float u_brightness_low;
    uniform float u_brightness_high;
    uniform float u_spin;
    uniform float u_saturation;
    uniform sampler2D u_image;
    varying vec2 v_pos;

    vec3 u_high_vec;
    vec3 u_low_vec;

    vec3 greyscale;
    vec3 original;
    vec3 saturated;

    float len;

    void main() {

        u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);
        u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);

        // http://www.laurenscorijn.com/articles/colormath-basics
        original = texture2D(u_image, v_pos).xyz;
        len = length(original) / 2.0;

        greyscale = vec3(len, len, len);

        saturated = (u_saturation * original) + ((1.0 - u_saturation) * greyscale);

        gl_FragColor = vec4(
            mix(
                u_high_vec,
                u_low_vec,
                // texture2D(u_image, v_pos).xyz
                saturated
            ) * mat3(
                1, 0, 0,
                0, cos(u_spin), -sin(u_spin),
                0, sin(u_spin), cos(u_spin)), 1.0);
    }
</script>

<!-- these are the point shaders -->
<script id="point-vertex" type="x-shader/x-vertex">
precision mediump float;

#define scale 63.0
#define root2 1.42

uniform mat4 u_posmatrix;
uniform vec2 u_size;
uniform vec2 u_tpos;
uniform vec2 u_tsize;
uniform mat2 u_rotationmatrix;

attribute vec2 a_pos;
attribute vec2 a_slope;
varying mat2 v_rotationmatrix;

void main(void) {

    gl_Position = u_posmatrix * vec4(floor(a_pos/2.0), 0, 1);
    gl_PointSize = u_size.x * root2;

    float angle = atan(a_slope.y, a_slope.x);

    v_rotationmatrix = mat2(
        cos(angle), -sin(angle),
        sin(angle), cos(angle)
    ) * u_rotationmatrix;
}

</script>
<script id="point-fragment" type="x-shader/x-fragment">
#define root2 1.42
precision mediump float;

uniform sampler2D u_image;
uniform vec2 u_size;
uniform vec2 u_tpos;
uniform vec2 u_tsize;

varying vec2 imageCoords;
varying mat2 v_rotationmatrix;

void main(void) {

    vec2 pos = v_rotationmatrix * (gl_PointCoord * 2.0 - 1.0) * root2 / 2.0 + 0.5;
    vec2 imageCoord = (u_tpos + u_size * pos)/ u_tsize;

    float inbounds = step(0.0, pos.x) * step(0.0, pos.y) *
        (1.0 - step(1.0, pos.x)) * (1.0 - step(1.0, pos.y));

    gl_FragColor = texture2D(u_image, imageCoord) * inbounds;
    gl_FragColor.rgb *= gl_FragColor.a;
}
</script>

<!-- these are the shaders for rendering from a framebuffer -->
<script id="composite-vertex" type="x-shader/x-vertex">
attribute vec2 a_pos;

uniform mat4 u_posmatrix;
varying vec2 v_pos;

void main() {
    gl_Position = u_posmatrix * vec4(a_pos, 0, 1);
    v_pos = gl_Position.xy;
}

</script>
<script id="composite-fragment" type="x-shader/x-fragment">
precision mediump float;

uniform sampler2D u_image;
uniform float u_opacity;

varying vec2 v_pos;

void main() {
    gl_FragColor = texture2D(u_image, v_pos / 2.0 + 0.5) * u_opacity;
}
</script>



<!-- these are the shaders for rendering filled areas -->
<script id="area-vertex" type="x-shader/x-vertex">
precision mediump float;

attribute vec2 a_pos;

uniform mat4 u_posmatrix;

void main() {
    gl_Position = u_posmatrix * vec4(floor(a_pos / 2.0), 0, 1);
    gl_PointSize = 2.0;
}
</script>
<script id="area-fragment" type="x-shader/x-fragment">
precision mediump float;

uniform vec4 u_color;

void main() {
    gl_FragColor = u_color;

}
</script>

<!-- these are the shaders for rendering antialiased lines -->
<script id="line-vertex" type="x-shader/x-vertex">
precision mediump float;

// floor(127 / 2) == 63.0
// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is
// stored in a byte (-128..127). we scale regular normals up to length 63, but
// there are also "special" normals that have a bigger length (of up to 126 in
// this case).
#define scale 63.0

attribute vec2 a_pos;
attribute vec2 a_extrude;
attribute float a_linesofar;

// posmatrix is for the vertex position, exmatrix is for rotating and projecting
// the extrusion vector.
uniform mat4 u_posmatrix;
uniform mat4 u_exmatrix;


uniform float u_debug;

// shared
uniform float u_ratio;
uniform vec2 u_linewidth;
uniform vec4 u_color;
uniform float u_point;

varying vec2 v_normal;
varying float v_linesofar;

void main() {
    // We store the texture normals in the most insignificant bit
    // transform y so that 0 => -1 and 1 => 1
    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap
    // y is 1 if the normal points up, and -1 if it points down
    vec2 normal = mod(a_pos, 2.0);
    normal.y = sign(normal.y - 0.5);
    v_normal = normal;

    // Scale the extrusion vector down to a normal and then up by the line width
    // of this vertex.
    vec2 extrude = a_extrude / scale;
    vec2 dist = u_linewidth.s * extrude * (1.0 - u_point);

    // If the x coordinate is the maximum integer, we move the z coordinates out
    // of the view plane so that the triangle gets clipped. This makes it easier
    // for us to create degenerate triangle strips.
    float z = step(32767.0, a_pos.x);

    // When drawing points, skip every other vertex
    z += u_point * step(1.0, v_normal.y);

    // Remove the texture normal bit of the position before scaling it with the
    // model/view matrix. Add the extrusion vector *after* the model/view matrix
    // because we're extruding the line in pixel space, regardless of the current
    // tile's zoom level.
    gl_Position = u_posmatrix * vec4(floor(a_pos / 2.0), 0.0, 1.0) + u_exmatrix * vec4(dist, z, 0.0);
    v_linesofar = a_linesofar * u_ratio;


    gl_PointSize = 2.0 * u_linewidth.s - 1.0;
}
</script>

<script id="line-fragment" type="x-shader/x-fragment">
precision mediump float;

// shared
uniform float u_debug;
uniform vec2 u_linewidth;
uniform vec4 u_color;
uniform float u_point;

uniform vec2 u_dasharray;

varying vec2 v_normal;
varying float v_linesofar;

void main() {
    // Calculate the distance of the pixel from the line in pixels.
    float dist = length(v_normal) * (1.0 - u_point) + u_point * length(gl_PointCoord * 2.0 - 1.0);

    dist *= u_linewidth.s;

    // Calculate the antialiasing fade factor. This is either when fading in
    // the line in case of an offset line (v_linewidth.t) or when fading out
    // (v_linewidth.s)
    float alpha = clamp(min(dist - (u_linewidth.t - 1.0), u_linewidth.s - dist), 0.0, 1.0);

    // Calculate the antialiasing fade factor based on distance to the dash.
    // Only affects alpha when line is dashed
    float pos = mod(v_linesofar, u_dasharray.x + u_dasharray.y);
    alpha *= max(step(0.0, -u_dasharray.y), clamp(min(pos, u_dasharray.x - pos), 0.0, 1.0));

    gl_FragColor = u_color * alpha;

    if (u_debug > 0.0) {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
}
</script>

<!-- these are the shaders for rendering labels -->
<script id="label-vertex" type="x-shader/x-vertex">
precision mediump float;

attribute vec2 a_pos;
attribute vec2 a_offset;
attribute vec2 a_tex;

uniform vec2 u_texsize;
uniform mat4 u_posmatrix;
uniform mat4 u_resizematrix;

varying vec2 v_tex;

void main() {
    vec2 a = a_offset;
    gl_Position = u_posmatrix * vec4(a_pos, 0, 1) + u_resizematrix * vec4(a_offset, 0, 1);
    v_tex = a_tex / u_texsize;
}
</script>

<script id="label-fragment" type="x-shader/x-fragment">
precision mediump float;

uniform sampler2D u_sampler;
uniform vec4 u_color;
varying vec2 v_tex;

void main() {
    vec4 c = texture2D(u_sampler, v_tex);
    gl_FragColor = vec4(u_color.r, u_color.g, u_color.b, u_color.a * c.a);
}
</script>

<script id="sdf-vertex" type="x-shader/x-vertex">
precision mediump float;

attribute vec2 a_pos;
attribute vec2 a_offset;
attribute vec2 a_tex;
attribute float a_angle;
attribute float a_minzoom;


// posmatrix is for the vertex position, exmatrix is for rotating and projecting
// the extrusion vector.
uniform mat4 u_posmatrix;
uniform mat4 u_exmatrix;
uniform float u_angle;
uniform float u_zoom;

uniform vec2 u_texsize;

varying vec2 v_tex;

void main() {

    float rev = 1.0;
    // We're using an int16 range for the angles.
    if (abs(a_angle + u_angle) > 32767.0) rev = -1.0;

    // If the label should be invisible, we move the vertex outside
    // of the view plane so that the triangle gets clipped. This makes it easier
    // for us to create degenerate triangle strips.
    float z = 1.0 - step(a_minzoom, u_zoom);

    gl_Position = u_posmatrix * vec4(a_pos, 0, 1) + rev * u_exmatrix * vec4(a_offset / 64.0, z, 0);
    v_tex = a_tex * 4.0 / u_texsize;
}
</script>



<script id="sdf-fragment" type="x-shader/x-fragment">
precision mediump float;

uniform sampler2D u_texture;
uniform vec4 u_color;
uniform float u_buffer;
uniform float u_gamma;

varying vec2 v_tex;

void main() {
    float dist = texture2D(u_texture, v_tex).a;
    float alpha = smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, dist);
    gl_FragColor = u_color * alpha;
    // gl_FragColor = vec4(0, 0, 0, 1);
}
</script>
</head>
<body>

<div id="map"></div>

</body>
</html>
