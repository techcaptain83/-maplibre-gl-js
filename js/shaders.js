// NOTE: DO NOT CHANGE THIS FILE. IT IS AUTOMATICALLY GENERATED.
var shaders = {
    "area": {
        "fragment": "precision mediump float;\n\nuniform vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n\n}\n",
        "vertex": "// these are the shaders for rendering filled areas\n\nprecision mediump float;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_posmatrix;\n\nvoid main() {\n    gl_Position = u_posmatrix * vec4(floor(a_pos / 2.0), 0, 1);\n    gl_PointSize = 2.0;\n}\n"
    },
    "composite": {
        "fragment": "precision mediump float;\n\nuniform sampler2D u_image;\nuniform float u_opacity;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_FragColor = texture2D(u_image, v_pos / 2.0 + 0.5) * u_opacity;\n}\n",
        "vertex": "attribute vec2 a_pos;\n\nuniform mat4 u_posmatrix;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_posmatrix * vec4(a_pos, 0, 1);\n    v_pos = gl_Position.xy;\n}\n"
    },
    "debug": {
        "fragment": "precision mediump float;\n\nuniform vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n",
        "vertex": "precision mediump float;\n\nattribute vec2 a_pos;\n\nuniform float u_pointsize;\nuniform mat4 u_posmatrix;\n\nvoid main() {\n    gl_Position = u_posmatrix * vec4(a_pos, step(32767.0, a_pos.x), 1);\n    gl_PointSize = u_pointsize;\n}\n"
    },
    "label": {
        "fragment": "precision mediump float;\n\nuniform sampler2D u_sampler;\nuniform vec4 u_color;\nvarying vec2 v_tex;\n\nvoid main() {\n    vec4 c = texture2D(u_sampler, v_tex);\n    gl_FragColor = vec4(u_color.r, u_color.g, u_color.b, u_color.a * c.a);\n}\n",
        "vertex": "precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_tex;\n\nuniform vec2 u_texsize;\nuniform mat4 u_posmatrix;\nuniform mat4 u_resizematrix;\n\nvarying vec2 v_tex;\n\nvoid main() {\n    vec2 a = a_offset;\n    gl_Position = u_posmatrix * vec4(a_pos, 0, 1) + u_resizematrix * vec4(a_offset, 0, 1);\n    v_tex = a_tex / u_texsize;\n}\n"
    },
    "line": {
        "fragment": "precision mediump float;\n\n// shared\nuniform float u_debug;\nuniform vec2 u_linewidth;\nuniform vec4 u_color;\nuniform float u_point;\n\nuniform vec2 u_dasharray;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * (1.0 - u_point) + u_point * length(gl_PointCoord * 2.0 - 1.0);\n\n    dist *= u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float alpha = clamp(min(dist - (u_linewidth.t - 1.0), u_linewidth.s - dist), 0.0, 1.0);\n\n    // Calculate the antialiasing fade factor based on distance to the dash.\n    // Only affects alpha when line is dashed\n    float pos = mod(v_linesofar, u_dasharray.x + u_dasharray.y);\n    alpha *= max(step(0.0, -u_dasharray.y), clamp(min(pos, u_dasharray.x - pos), 0.0, 1.0));\n\n    gl_FragColor = u_color * alpha;\n\n    if (u_debug > 0.0) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n}\n",
        "vertex": "// these are the shaders for rendering antialiased lines\nprecision mediump float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n#define scale 63.0\n\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute float a_linesofar;\n\n// posmatrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform mat4 u_posmatrix;\nuniform mat4 u_exmatrix;\n\n\nuniform float u_debug;\n\n// shared\nuniform float u_ratio;\nuniform vec2 u_linewidth;\nuniform vec4 u_color;\nuniform float u_point;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\n\nvoid main() {\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    vec2 extrude = a_extrude / scale;\n    vec2 dist = u_linewidth.s * extrude * (1.0 - u_point);\n\n    // If the x coordinate is the maximum integer, we move the z coordinates out\n    // of the view plane so that the triangle gets clipped. This makes it easier\n    // for us to create degenerate triangle strips.\n    float z = step(32767.0, a_pos.x);\n\n    // When drawing points, skip every other vertex\n    z += u_point * step(1.0, v_normal.y);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix. Add the extrusion vector *after* the model/view matrix\n    // because we're extruding the line in pixel space, regardless of the current\n    // tile's zoom level.\n    gl_Position = u_posmatrix * vec4(floor(a_pos / 2.0), 0.0, 1.0) + u_exmatrix * vec4(dist, z, 0.0);\n    v_linesofar = a_linesofar * u_ratio;\n\n\n    gl_PointSize = 2.0 * u_linewidth.s - 1.0;\n}\n"
    },
    "point": {
        "fragment": "#define root2 1.42\nprecision mediump float;\n\nuniform sampler2D u_image;\nuniform vec2 u_tl;\nuniform vec2 u_br;\n\nvarying mat2 v_rotationmatrix;\n\nvoid main(void) {\n\n    vec2 pos = v_rotationmatrix * (gl_PointCoord * 2.0 - 1.0) * root2 / 2.0 + 0.5;\n\n    float inbounds = step(0.0, pos.x) * step(0.0, pos.y) *\n        (1.0 - step(1.0, pos.x)) * (1.0 - step(1.0, pos.y));\n\n    gl_FragColor = texture2D(u_image, mix(u_tl, u_br, pos)) * inbounds;\n\n    gl_FragColor.rgb *= gl_FragColor.a;\n}\n",
        "vertex": "precision mediump float;\n\n#define scale 63.0\n#define root2 1.42\n\nuniform mat4 u_posmatrix;\nuniform vec2 u_size;\nuniform mat2 u_rotationmatrix;\n\nattribute vec2 a_pos;\nattribute vec2 a_slope;\nvarying mat2 v_rotationmatrix;\n\nvoid main(void) {\n\n    gl_Position = u_posmatrix * vec4(floor(a_pos/2.0), 0, 1);\n    gl_PointSize = u_size.x * root2;\n\n    float angle = atan(a_slope.y, a_slope.x);\n\n    v_rotationmatrix = mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    ) * u_rotationmatrix;\n}\n"
    },
    "raster": {
        "fragment": "precision mediump float;\n\nuniform float u_brightness_low;\nuniform float u_brightness_high;\nuniform float u_spin;\nuniform float u_saturation;\nuniform sampler2D u_image;\nvarying vec2 v_pos;\n\nvec3 u_high_vec;\nvec3 u_low_vec;\n\nvec3 greyscale;\nvec3 original;\nvec3 saturated;\n\nfloat len;\n\nvoid main() {\n\n    u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n    u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n\n    // http://www.laurenscorijn.com/articles/colormath-basics\n    original = texture2D(u_image, v_pos).xyz;\n    len = length(original) / 2.0;\n\n    greyscale = vec3(len, len, len);\n\n    saturated = (u_saturation * original) + ((1.0 - u_saturation) * greyscale);\n\n    gl_FragColor = vec4(\n        mix(\n            u_high_vec,\n            u_low_vec,\n            // texture2D(u_image, v_pos).xyz\n            saturated\n        ) * mat3(\n            1, 0, 0,\n            0, cos(u_spin), -sin(u_spin),\n            0, sin(u_spin), cos(u_spin)), 1.0);\n}\n",
        "vertex": "precision mediump float;\nuniform mat4 u_posmatrix;\nuniform float u_brightness_low;\nuniform float u_brightness_high;\nuniform float u_spin;\nattribute vec2 a_pos;\nvarying vec2 v_pos;\n\nvoid main(void) {\n    gl_Position = u_posmatrix * vec4(a_pos, step(32767.0, a_pos.x), 1);\n    v_pos = a_pos / 4096.0;\n}\n"
    },
    "sdf": {
        "fragment": "precision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_color;\nuniform float u_buffer;\nuniform float u_gamma;\n\nvarying vec2 v_tex;\n\nvoid main() {\n    float dist = texture2D(u_texture, v_tex).a;\n    float alpha = smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, dist);\n    gl_FragColor = u_color * alpha;\n    // gl_FragColor = vec4(0, 0, 0, 1);\n}\n",
        "vertex": "precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_tex;\nattribute float a_angle;\nattribute float a_minzoom;\n\n\n// posmatrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform mat4 u_posmatrix;\nuniform mat4 u_exmatrix;\nuniform float u_angle;\nuniform float u_zoom;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\n\nvoid main() {\n\n    float rev = 1.0;\n    // We're using an int16 range for the angles.\n    if (abs(a_angle + u_angle) > 32767.0) rev = -1.0;\n\n    // If the label should be invisible, we move the vertex outside\n    // of the view plane so that the triangle gets clipped. This makes it easier\n    // for us to create degenerate triangle strips.\n    float z = 1.0 - step(a_minzoom, u_zoom);\n\n    gl_Position = u_posmatrix * vec4(a_pos, 0, 1) + rev * u_exmatrix * vec4(a_offset / 64.0, z, 0);\n    v_tex = a_tex * 4.0 / u_texsize;\n}\n"
    }
};
